###############################################################################
# Global makefile configuration
###############################################################################
# Name of the Debian Source Package
DSC_NAME := $(shell dpkg-parsechangelog -S Source)
# Debian package version (<upstream>-<inc>)
DEB_VERSION := $(shell dpkg-parsechangelog -S Version)
# Debian package upstream version (<upstream>)
UPSTREAM_VERSION := $(shell echo $(DEB_VERSION) | rev | cut -d- -f2- | rev)
# Original upstream archive (generated from git repo)
UPSTREAM_TARBALL := $(DSC_NAME)_$(UPSTREAM_VERSION).orig.tar.xz
# Python module version
PY_VERSION := $(shell grep __version__ uno/__init__.py | cut -d= -f2- | tr -d \" | cut '-d ' -f2-)
# Name of the Python module
PY_NAME := $(shell grep '^name =' pyproject.toml | cut -d= -f2- | tr -d \" | cut '-d ' -f2-)
ifneq ($(PY_NAME),uno)
$(warning unexpected Python module name: '$(PY_NAME)')
endif
# Docker image for the Debian Builder container
DEB_BUILDER ?= mentalsmash/debian-builder:latest
# Docker image for the Debian Tester container
DEB_TESTER ?= mentalsmash/debian-tester:latest
# Local uno clone
UNO_DIR ?= $(shell pwd)
# Directory where to generate test logs
# When running inside do It MUST be a subdirectory of UNO_DIR
TEST_RESULTS_DIR ?= $(UNO_DIR)/test-results
# A unique ID for the test run
TEST_ID ?= local
# The date when the tests were run
TEST_DATE ?= $(shell date +%Y%m%d-%H%M%S)
# Common prefix for the JUnit XML report generated by tests
TEST_JUNIT_REPORT ?= $(PY_NAME)-test-$(TEST_ID)__$(TEST_DATE)
# Docker image used to run tests
TEST_IMAGE ?= mentalsmash/uno-test-runner:latest
# Global flag telling the makefile to perform actions (e.g. run unit test) in a container.
IN_DOCKER ?=
# Directory targeted by the fix-root-permissions target
FIX_DIR ?= $(UNO_DIR)

ifneq ($(UPSTREAM_VERSION),$(PY_VERSION))
$(warning unexpected debian upstream version ('$(UPSTREAM_VERSION)' != '$(PY_VERSION)'))
endif
ifneq ($(DSC_NAME),$(PY_NAME))
$(warning unexpected debian source package name ('$(DSC_NAME)' != '$(PY_NAME)'))
endif
ifeq ($(wildcard $(RTI_LICENSE_FILE)),)
$(warning no RTI_LICENSE_FILE detected or invalid ('$(RTI_LICENSE_FILE)'))
endif

ifneq ($(NO_LICENSE),)
ifneq ($(RTI_LICENSE_FILE),)
$(warning suppressing RTI_LICENSE_FILE := $(RTI_LICENSE_FILE))
endif
RTI_LICENSE_FILE :=
else # ifneq ($(NO_LICENSE),)
ifeq ($(RTI_LICENSE_FILE),)
$(warning no RTI_LICENSE_FILE specified)
endif
RTI_LICENSE_FILE := $(realpath $(RTI_LICENSE_FILE))
endif # ifneq ($(NO_LICENSE),)
# Export to make sure it's available to subprocesses
export RTI_LICENSE_FILE

ifneq ($(NO_LICENSE),)
IN_DOCKER_PREFIX := \
  docker run --rm \
    -v $(UNO_DIR):$(UNO_DIR) \
    $$([ -z "$(NO_LICENSE)" ] || printf -- '-v $(RTI_LICENSE_FILE):/rti_license.dat') \
    -w $(UNO_DIR) \
    -e VERBOSITY=$(VERBOSITY) \
    -e DEBUG=$(DEBUG) \
    -e EXPECT_MIDDLEWARE=$(EXPECT_MIDDLEWARE) \
    $(TEST_IMAGE)

EXPECT_MIDDLEWARE :=
else # ifneq ($(NO_LICENSE),)
IN_DOCKER_PREFIX :=

ifeq ($(UNO_MIDDLEWARE),)
EXPECT_MIDDLEWARE := uno.middleware.connext
else
EXPECT_MIDDLEWARE := $(UNO_MIDDLEWARE)
endif
endif # ifneq ($(NO_LICENSE),)

export EXPECT_MIDDLEWARE


.PHONY: \
  build \
  tarball \
  clean \
  debuild \
  changelog \
	debtest \
	test \
	test-unit \
	test-integration

# Perform all build tasks
build: build/default ;

# Build uno into a static binary using pyinstaller.sh
build/%: ../$(UPSTREAM_TARBALL)
	rm -rf $@ dist/bundle/$*
	mkdir -p distsrc
	tar -xvaf $< -C dist/src
	scripts/bundle/pyinstaller.sh $*

# Delete files generated by "build"
clean:
	rm -rf build

# Generate upstream archive
tarball: ../$(UPSTREAM_TARBALL) ;

../$(UPSTREAM_TARBALL):
	git ls-files --recurse-submodules | tar -cvaf $@ -T-

# Update changelog entry and append build codename to version
# Requires the Debian Builder image.
changelog:
	docker run --rm \
		-v $(UNO_DIR)/:/uno \
		-w /uno \
		$(DEB_BUILDER)  \
		/uno/scripts/bundle/update_changelog.sh

# Build uno's debian packages.
# Requires the Debian Builder image.
debuild:
	docker run --rm \
		-v $(UNO_DIR)/:/uno \
		-w /uno \
		$(DEB_BUILDER)  \
		/uno/scripts/debian_build.sh

# Run integration tests using the debian package.
# Requires the Debian Tester image
debtest: .venv
	. .venv/bin/activate; \
	  TEST_IMAGE=$(DEB_TESTER) \
	  TEST_RUNNER=runner \
	  DEV=y \
	  pytest -s -v \
		  --junit-xml=$(TEST_RESULTS_DIR)/$(TEST_JUNIT_REPORT)__unit.xml \
		  test/integration $(INTEGRATION_TEST_ARGS)

# Convenience target to:
# - build debian packages
# - build debian tester image
# - run integration tests
debvalidate:
	$(MAKE) debuild
	$(MAKE) dockerimage-debian-tester
	$(MAKE) debtest

# Run both unit and integration tests
test: test-unit test-integration ;

# Run unit tests
BASE_UNIT_TEST_COMMAND := \
  pytest -s -v \
    --junit-xml=$(TEST_RESULTS_DIR)/$(TEST_JUNIT_REPORT)__unit.xml \
    test/unit
ifneq ($(CI),)
# When run by a CI test, the test image is expected to contain an
# embedded RTI license at /rti_license.dat. To test without it, we
# must change the test command to 
ifneq ($(NO_LICENSE),)
UNIT_TEST_COMMAND := \
	sh -exc '\
	rm /rti_license.dat; \
	unset RTI_LICENSE_FILE; \
	$(BASE_UNIT_TEST_COMMAND) $(UNIT_TEST_ARGS)'
endif # ifneq ($(NO_LICENSE),)
else
UNIT_TEST_COMMAND := $(BASE_UNIT_TEST_COMMAND) $(UNIT_TEST_ARGS)
endif # ifneq ($(CI),)

test-unit: .venv
	mkdir -p $(TEST_RESULTS_DIR)
	[ -z "$(IN_DOCKER)" ] || . .venv/bin/activate; \
	  $(IN_DOCKER_PREFIX) $(UNIT_TEST_COMMAND) $(UNIT_TEST_ARGS)

# Run integration tests
test-integration: .venv
	mkdir -p $(TEST_RESULTS_DIR)
	. .venv/bin/activate; \
	  DEV=y \
	  pytest -s -v \
	    --junit-xml=$(TEST_RESULTS_DIR)/$(TEST_JUNIT_REPORT)__integration.xml \
	    test/integration \
	    $(INTEGRATION_TEST_ARGS)

fix-root-permissions:
	docker run --rm \
	  -v $(FIX_DIR):/workspace \
	  $(TEST_IMAGE) \
	  fix-root-permissions $$(id -u):$$(id -g) /workspace

# Install uno and its dependencies in a virtual environment.
# Dynamically provision poetry in a separate, temporary, virtual environment
# which is deleted upon a successfull run.
venv-install: .venv ;

.venv:
	set -e; \
	  rm -rf .venv-poetry; \
	  python3 -m venv .venv-poetry; \
	  . .venv-poetry/bin/activate; \
	  pip3 install -U poetry; \
	  deactivate; \
	  .venv-poetry/bin/poetry install --with=dev $$(\
		  [ -n "$(UNO_MIDDLEWARE)" ] || printf -- --with=connext \
	  ); \
	  rm -rf .venv-poetry; \
	  if [ -n "$(UNO_MIDDLEWARE)" ]; then \
		  . .venv/bin/activate; \
		  pip3 install -U -e plugins/$(UNO_MIDDLEWARE); \
			deactivate; \
	  fi; \


# Convenience target to build an image with `docker compose build`
dockerimage-%:
	docker compose build $*


